# Use the shiny library
library(shiny)
# Use the pdfetch for yahoo finance
library(pdfetch)

# Server part of the application
shinyServer(
  function(input, output, session) {

    # Plotting the graphical representation
    output$plot <- renderPlot({

      # Check for the modeltype
      # For discrete
      if(input$modelType == 'discrete') {
        # Switch case for all the discrete probabilities models
        switch (input$model,
          # For Bernoulli model
          'bernoulli' = {
            # Diving the screen in to two column
            par(mfrow=c(1,2))
            # Density of data generated by rbinom
            Density <- density(rbinom(input$s,1,input$p))
            # Plot the first graph of density
            plot(Density, main="Kernel Density of generated data")
            # Polygen with color red and border blue
            polygon(Density, col="red", border="blue")
            # Creating the range for x axis
            x=0:1
            # Plot the first graph of polygon
            plot(x,dbinom(x,1,input$p))
          },

          # For Binomial model
          'binomial' = {
            # Diving the screen in to two column
            par(mfrow=c(1,2))
            # Plot the first graph of density
            d <- density(rbinom(input$s, input$n, input$p))
            plot(d, main="Kernel Density of generated data")
            # Polygen with color red and border blue
            polygon(d, col="red", border="blue")
            # Creating the range for x axis
            x=0:input$n
            # Plot the first graph of polygon
            plot(x,dbinom(x, input$n, input$p))
          },

          # For poisson model
          'poisson' = {
            # Diving the screen in to two column
            par(mfrow=c(1,2))
            # Generating the random data
            D=rpois(input$s, input$lam)
            # using the table function on that generated data
            tab=table(D)
            # Plotting the bar graph
            barplot(tab,col='blue')
            # Range for x axis 
            x1=0:input$max
            # Range for y axis 
            y1=dpois(x1,input$lam)
            # plot the graph 
            plot(x1,y1,type='b')
          },

          # For Geometric model
          'geometric' = {
            # Diving the screen in to two column
            par(mfrow=c(1,2))
            # Generating the random data
            D=rgeom(input$s, input$p)
            # using the table function on that generated data
            tab=table(D)
            # Plotting the bar graph
            barplot(tab,col='blue')
            # Range for x axis 
            x2=0:input$max
            # Range for y axis 
            y2=dgeom(x2,input$p)
            # plot the graph 
            plot(x2,y2,type='b')
          },

          # For Geometric model
          'hypergeometric' = {
            # Diving the screen in to two column
            par(mfrow=c(1,2))
            # Generating the random data
            D=rhyper(nn=input$s, m=input$m, n=input$n, k=rep(input$k, input$s))
            # using the table function on that generated data
            tab=table(D)
            # Plotting the bar graph
            barplot(tab,col='blue')
            # Range for x axis 
            x2=0:input$s
            # Range for y axis 
            y2=dhyper(x2, m=input$m, n=input$n, k=input$k, log=FALSE)
            # plot the graph 
            plot(x2,y2,type='b')
          }
        )
      }

      # For model type continuous
      if(input$modelType == 'continuous') {
        # Switch case for all the continuous probabilities models
        switch (input$modelCont,
          # For Uniform model
          'uniform' = {
            # Storing a input
            a <- input$a
            # Storing b input
            b <- input$b
            # Storing s input
            n1 <- input$s
            # Generating the random data
            rand.unif <- runif(n1, min = a, max = b)
            # Plotting the hist graph
            hist(rand.unif,
                 freq = FALSE,
                 xlab = 'x',
                 ylim = c(0, 0.4),
                 xlim = c(-3,3),
                 density = 20,
                 main = "Uniform distribution")
            curve(dunif(x, min = a, max = b),
                  from = -3, to = 3,
                  n = n1,
                  col = "darkblue",
                  lwd = 2,
                  add = TRUE,
                  yaxt = "n",
                  ylab = 'probability')
          },

          # For Uniform model
          'normal' = {
            # Generating the random data
            x=seq(-input$i,input$i,0.01)
            # Plotting the graph
            plot(x,dnorm(x,input$mu,input$sigma),type='l', col='red')
          },

          # For Exponential model
          'exponential' = {
            # Generating the random data
            x=seq(0,input$i,0.01)
            # Plotting the graph
            plot(x,dexp(x,input$lam),type='l',col='green')
          },

          # For Gamma model
          'gamma' = {
            # Generating the random data
            x=seq(0,input$i,0.01)
            # Plotting the graph
            plot(x,dgamma(x,input$sigma,input$lam),type='l',col='blue')
          },

          # For Chi Squared model
          'chisquared' = {
            # Generating the random data
            x=seq(0,input$i,0.01)
            # Plotting the graph
            plot(x,dchisq(x,input$k),type='l',col='black')
          }
        )
      }
    })

    # Tab to display the summary for each model
    output$summary <- renderPrint({

      # For model type discrete
      if(input$modelType == 'discrete') {
        # Switch case for all the discrete probabilities models
        switch (input$model,
          # For Bernoulli model
          'bernoulli' = {
            # Show the summary for random generated data
            summary(rbinom(input$s, 1, input$p))
          },

          # For Binomial model
          'binomial' = {
            # Show the summary for random generated data
            summary(rbinom(input$s, input$n, input$p))
          },

          # For poisson model
          'poisson' = {
            # Show the summary for random generated data
            summary(rpois(input$s, input$lam))
          },

          # For Geometric model
          'geometric' = {
            # Show the summary for random generated data
            summary(rgeom(input$s, input$p))
          },

          # For Hyper Geometric model
          'hypergeometric' = {
            # Show the summary for random generated data
            summary(rhyper(nn=input$s, m=input$m, n=input$n, k=rep(input$k, input$s)))
          }
        )
      } else if(input$modelType == 'continuous') {
      # For model type continuous
        # Switch case for all the continuous probabilities models
        switch (input$modelCont,
          # For Uniform model
          'uniform' = {
            # Show the summary for random generated data
            summary(runif(input$s,input$a, input$b))
          },

          # For Normal model
          'normal' = {
            c(pnorm(input$s,input$mu, input$sigma))
            # Show the summary for random generated data
            summary(rnorm(input$s,input$mu, input$sigma))
          },

          # For Exponential model
          'exponential' = {
            c(pexp(input$s,input$lam))
            # Show the summary for random generated data
            summary(rexp(input$s,input$lam))
          },

          # For Gamma model
          'gamma' = {
            # Show the summary for random generated data
            summary(rgamma(input$s,input$sigma,input$lam))
          },

          # For Chi Square model
          'chisquared' = {
            # Show the summary for random generated data
            summary(rchisq(input$s,input$k))
          }
        )
      }
    })

    # Tab displayed the table of simulated data
    output$table <- renderTable({

      # For model type discrete
      if(input$modelType == 'discrete') {
        # Switch case for all the discrete probabilities models
        switch (input$model,
          # For Bernoulli model
          'bernoulli' = {
            # Collect the random generated data
            c(rbinom(input$s,1,input$p))
          },

          # For Binomial model
          'binomial' = {
            # Collect the random generated data
            c(rbinom(input$s, input$n, input$p))
          },

          # For Poisson model
          'poisson' = {
            # Collect the random generated data
            c(rpois(input$s, input$lam))
          },

          # For Geometric model
          'geometric' = {
            # Collect the random generated data
            c(rgeom(input$s, input$p))
          },

          # For Hyper Geometric model
          'hypergeometric' = {
            # Collect the random generated data
            c(rhyper(nn=input$s, m=input$m, n=input$n, k=rep(input$k, input$s)))
          }
        )
      } else if(input$modelType == 'continuous') {
      # For model type continuous
        # Switch case for all the continuous probabilities models
        switch (input$modelCont,
          # For Uniform model
          'uniform' = {
            # Collect the random generated data
            c(runif(input$s,input$a, input$b))
          },

          # For Normal model
          'normal' = {
            # Collect the random generated data
            c(rnorm(input$s,input$mu, input$sigma))
          },

          # For Exponential model
          'exponential' = {
            # Collect the random generated data
            c(rexp(input$s,input$lam))
          },

          # For Gamma model
          'gamma' = {
            # Collect the random generated data
            c(rgamma(input$s,input$sigma,input$lam))
          },

          # For Chi Square model
          'chisquared' = {
            # Collect the random generated data
            c(rchisq(input$s,input$k))
          }
        )
      }
    })

    # Storing the dataset into myData
    myData <- reactive({
      # Switch case to the input type
      switch(input$predInputType,
        # For File input
        'preFile' = {
          # Storing hte input file in file1 variable
          file1 <- input$datafile
          # Return null if file1 is empty
          if (is.null(file1)) {
            return()
          }
          # Read the CSV file and store in data
          data = read.csv(file=file1$datapath)
          data
        },
        # For Inbuild input
        'preInbuild' = {
          # get the inbuild dataset and store in data
          data = data.frame(get(input$preInbuildFile))
          data
        },
        # For URL input
        'preUrl' = {
          # Read the dataset from URL
          data = read.csv(input$preUrl)
          data
        },
        # For Yahoo Finance input
        'preYahoo' = {
          # Set from date to one year from now
          fromDate = Sys.Date() - 1*365;
          # Get output from Yahoo api
          out = pdfetch_YAHOO(input$preYahoo, fields = c("open", "high", "low", "close", "adjclose", "volume"), from = fromDate)
          # Convert it into dataframe
          stockData = data.frame(out)

          # Get the name of column name
          tick_open <- paste(input$preYahoo, sep = "", ".open")
          tick_high <- paste(input$preYahoo, sep = "", ".high")
          tick_low <- paste(input$preYahoo, sep = "", ".low")
          tick_volume <- paste(input$preYahoo, sep = "", ".volume")
          tick_close <- paste(input$preYahoo, sep = "", ".close")

          # Renaming Columns
          names(stockData)[names(stockData) == tick_open] <- "Open"
          names(stockData)[names(stockData) == tick_high] <- "High"
          names(stockData)[names(stockData) == tick_low] <- "Low"
          names(stockData)[names(stockData) == tick_volume] <- "Volumn"
          names(stockData)[names(stockData) == tick_close] <- "Close"

          # omit the empty value and store in data variable
          data = na.omit(stockData)
          data
        }
      )

    })

    # Observe the change in myData and update the columns input
    observe({
      # Update the columns input
      updateSelectInput(session, inputId = "pred_columns", choices = colnames(myData()))
    })

    # Render the data with datatable
    output$extdata = DT::renderDataTable({
      # Get the data
      extdata <- myData()
      # Show the data in Datatable
      DT::datatable(extdata, options = list(lengthChange = TRUE))
    })

    # Tab for show the prediction 
    output$prediction <- renderPrint({

        # Show the column name that user have selected
        print(paste('Selected Column : ',input$pred_columns))
        # Store the data in df
        df <- myData()
        # Get the selected column from the dataset
        x <- df[,input$pred_columns]

      # switch case for probability models
      switch (input$predmodel,
        # For Bermoulli
        'bernoulli' = {
          # Mean of the data
          p=mean(x)
          # Generate the random data based on that mean
          sim = rbinom(input$s, 1, p)
          # Prediction base on that mean
          if(mean(sim) > 0.5){
            pred = 1
          } else {
            pred = 0
          }
          # Display on the screen
          print(paste('Predicted Value : ', pred))
        },

        # For Poisson
        'poisson' = {
          # Display predicted value based on the random generated values
          print(paste('Predicted Value : ', mean(rpois(input$s, 1/mean(x)))))
        },

        # For Uniform
        'uniform' = {
          # Display predicted value based on the random generated values
          print(paste('Predicted Value : ', mean(rnorm(input$s))))
        },

        # For Normal
        'normal' = {
          # Display predicted value based on the random generated values
          print(paste('Predicted Value : ', mean(rnorm(input$s, mean(x), sd(x)))))
        },

        # For Exponential
        'exponential' = {
          # Display predicted value based on the random generated values
          print(paste('Predicted Value : ', mean(rexp(input$s, 1/mean(x)))))
        },
      )
    })


    hpData <- reactive({
      switch(input$hpInputType,
        'hpFile' = {
          file1 <- input$hpDatafile
          if (is.null(file1)) {
            return()
          }
          data = read.csv(file=file1$datapath)
          data
        },
        'hpInbuild' = {
          data = data.frame(get(input$hpInbuildFile))
          data
        },
        'hpUrl' = {
          data = read.csv(input$hpUrl)
          data
        },
        'hpYahoo' = {
          fromDate = Sys.Date() - 1*365;
          out = pdfetch_YAHOO(input$hpYahoo, fields = c("open", "high", "low", "close", "adjclose", "volume"), from = fromDate)
          stockData = data.frame(out)

          tick_open <- paste(input$hpYahoo, sep = "", ".open")
          tick_high <- paste(input$hpYahoo, sep = "", ".high")
          tick_low <- paste(input$hpYahoo, sep = "", ".low")
          tick_volume <- paste(input$hpYahoo, sep = "", ".volume")
          tick_close <- paste(input$hpYahoo, sep = "", ".close")

          # Renaming Columns
          names(stockData)[names(stockData) == tick_open] <- "Open"
          names(stockData)[names(stockData) == tick_high] <- "High"
          names(stockData)[names(stockData) == tick_low] <- "Low"
          names(stockData)[names(stockData) == tick_volume] <- "Volumn"
          names(stockData)[names(stockData) == tick_close] <- "Close"

          data = na.omit(stockData)
          data
        }
      )

    })

    observe({
      updateSelectInput(session, inputId = "hp_columns", choices = colnames(hpData()))
    })

    output$hpextdata = DT::renderDataTable({
      extdata <- hpData()
      DT::datatable(extdata, options = list(lengthChange = TRUE))
    })


    output$testResult <- renderPrint({

      df <- hpData()
      x <- df[,input$hp_columns]
      y <- df[,input$hp_columns_y]

      switch (input$hpType,
        'meanTest' = {
          mu = 0
          if(input$hpalternative == 'two.sided'){
            mu = input$hpMu
          }

          test = t.test(x=x, mu=mu, alternative=input$hpalternative)

          if(test$p.value < input$hpAlpha){
            decision='Reject H_0'
          }else{
            decision='Accept H_0'
          }

          print(paste('Decision: ', decision))
          if(input$hpalternative == 'two.sided'){
            L=mean(x)-abs(qnorm(input$hpAlpha/2))*sd(x)/sqrt(length(x))
            U=mean(x)+abs(qnorm(input$hpAlpha/2))*sd(x)/sqrt(length(x))
            print(paste('Lower Limit : ', L))
            print(paste('Higher Limit : ', U))
          }
        },

        'proportionTest' = {

          test = prop.test(x=sum(x), n=length(x), alternative=input$hpalternative)

          if(test$p.value < input$hpAlpha){
            decision='Reject H_0'
          }else{
            decision='Accept H_0'
          }
          print(paste('Decision: ', decision))

          if(input$hpalternative == 'two.sided'){
            p_hat=sum(x)/length(x)
            L=p_hat-abs(qnorm(alpha/2))*sqrt(p_hat*(1-p_hat)/length(x))
            U=p_hat+abs(qnorm(alpha/2))*sqrt(p_hat*(1-p_hat)/length(x))
            print(paste('Lower Limit : ', L))
            print(paste('Higher Limit : ', U))
          }
        },
      )
    })

    output$mayur_profile <- renderText({
      'I am Mayur Vaishnav, highly motivated and passionate MSc student in Data Analytics. A wide range of knowledge in statistics, mathematics, and analytics. I have over 2 years of experience in the IT industry for developing web applications.'
    })
  }
)
